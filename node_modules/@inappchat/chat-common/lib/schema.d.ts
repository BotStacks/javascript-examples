export type Maybe<T> = T | undefined;
export type InputMaybe<T> = T | undefined;
export type Exact<T extends {
    [key: string]: unknown;
}> = {
    [K in keyof T]: T[K];
};
export type MakeOptional<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]?: Maybe<T[SubKey]>;
};
export type MakeMaybe<T, K extends keyof T> = Omit<T, K> & {
    [SubKey in K]: Maybe<T[SubKey]>;
};
export type MakeEmpty<T extends {
    [key: string]: unknown;
}, K extends keyof T> = {
    [_ in K]?: never;
};
export type Incremental<T> = T | {
    [P in keyof T]?: P extends ' $fragmentName' | '__typename' ? T[P] : never;
};
/** All built-in and custom scalars, mapped to their actual values */
export type Scalars = {
    ID: {
        input: string;
        output: string;
    };
    String: {
        input: string;
        output: string;
    };
    Boolean: {
        input: boolean;
        output: boolean;
    };
    Int: {
        input: number;
        output: number;
    };
    Float: {
        input: number;
        output: number;
    };
    /**
     * A date-time string at UTC, such as 2007-12-03T10:15:30Z, is compliant with the date-time format outlined in section 5.6 of the RFC 3339 profile of the ISO 8601 standard for representation of dates and times using the Gregorian calendar.
     *
     * This scalar is a description of an exact instant on the timeline such as the instant that a user account was created.
     *
     * This scalar ignores leap seconds (thereby assuming that a minute constitutes 59 seconds). In this respect, it diverges from the RFC 3339 profile.
     *
     * Where an RFC 3339 compliant date-time string has a time-zone other than UTC, it is shifted to UTC. For example, the date-time string 2016-01-01T14:10:20+01:00 is shifted to 2016-01-01T13:10:20Z.
     */
    DateTime: {
        input: Date;
        output: Date;
    };
    /** The JSON scalar type represents JSON values as specified by ECMA-404 */
    JSON: {
        input: {
            [key: string]: any;
        };
        output: {
            [key: string]: any;
        };
    };
    /**
     * A field whose value is a valid decimal degrees latitude number(opens in a new tab) (53.471).
     *
     * The input value can be either in decimal (53.471) or sexagesimal (53° 21' 16") format.
     *
     * The output value is always in decimal format (53.471).
     *
     * The maximum decimal degrees' precision is 8. See Decimal Degrees Precision(opens in a new tab) for more information.
     */
    Latitude: {
        input: number;
        output: number;
    };
    /**
     * A field whose value is a valid decimal degrees longitude number(opens in a new tab) (53.471).
     *
     * The input value can be either in decimal (53.471) or sexagesimal (53° 21' 16") format.
     *
     * The output value is always in decimal format (53.471).
     *
     * The maximum decimal degrees' precision is 8. See Decimal Degrees Precision for more information.
     */
    Longitude: {
        input: number;
        output: number;
    };
    /** A field whose value conforms to the standard E.164 format as specified in E.164 specification(opens in a new tab). Basically, this is +17895551234. The very powerful libphonenumber library(opens in a new tab) is available to take that format, parse and display it in whatever display format you want. It can also be used to parse user input and get the E.164 format to pass into a schema. */
    PhoneNumber: {
        input: any;
        output: any;
    };
    /** A field whose value conforms to the standard URL format as specified in RFC3986(opens in a new tab), and it uses real JavaScript URL objects. */
    URL: {
        input: string;
        output: string;
    };
    /** A field whose value is a generic Universally Unique Identifier */
    UUID: {
        input: any;
        output: any;
    };
};
export type App = {
    __typename?: 'App';
    wek: Scalars['String']['output'];
};
/** A mutlimedia or data attachment to a message */
export type Attachment = {
    __typename?: 'Attachment';
    /** The address of the location */
    address?: Maybe<Scalars['String']['output']>;
    /** The raw data of the Attachment if it is a VCard */
    data?: Maybe<Scalars['String']['output']>;
    /** The duration of the audio or video in seconds */
    duration?: Maybe<Scalars['Int']['output']>;
    /** The height of the image or video in integer pixels */
    height?: Maybe<Scalars['Int']['output']>;
    /** The latitude of the location */
    latitude?: Maybe<Scalars['Latitude']['output']>;
    /** The longitude of the location */
    longitude?: Maybe<Scalars['Longitude']['output']>;
    /** The mime type of the attachment if it is a file, image, video or audio object */
    mime?: Maybe<Scalars['String']['output']>;
    /** The type of the Attachment */
    type: AttachmentType;
    /** The url of the file or 'data' if an arbitrary object */
    url: Scalars['String']['output'];
    /** The width of the image or video in integer pixels */
    width?: Maybe<Scalars['Int']['output']>;
};
/** An input variant of Attachment for sending messages */
export type AttachmentInput = {
    /** The address of the location */
    address?: InputMaybe<Scalars['String']['input']>;
    /** The raw data of the Attachment if it is a VCard */
    data?: InputMaybe<Scalars['String']['input']>;
    /** The duration of the audio or video in seconds */
    duration?: InputMaybe<Scalars['Int']['input']>;
    /** The height of the image or video in integer pixels */
    height?: InputMaybe<Scalars['Int']['input']>;
    /** The latitude of the location */
    latitude?: InputMaybe<Scalars['Latitude']['input']>;
    /** The longitude of the location */
    longitude?: InputMaybe<Scalars['Longitude']['input']>;
    /** The mime type of the attachment if it is a file, image, video or audio object */
    mime?: InputMaybe<Scalars['String']['input']>;
    /** The type of the Attachment */
    type: AttachmentType;
    /** The url of the file or 'data' if an arbitrary object */
    url: Scalars['String']['input'];
    /** The width of the image or video in integer pixels */
    width?: InputMaybe<Scalars['Int']['input']>;
};
/** The type of a Message attachment. Can be a File or some arbitrary data like Location or Vcard */
export declare enum AttachmentType {
    /** An audio file */
    Audio = "audio",
    /** An arbitrary file */
    File = "file",
    /** An image */
    Image = "image",
    /** A Location consisting of a combination of Latitude, Longitude and/or Address */
    Location = "location",
    /**
     * A VCard. According to Wikipedia: vCard, also known as VCF (Virtual Contact File), is a file format standard for electronic business cards.
     * vCards can be attached to e-mail messages, sent via Multimedia Messaging Service (MMS), on the World Wide Web,
     * instant messaging, NFC or through QR code. They can contain name and address information, phone numbers, e-mail addresses,
     * URLs, logos, photographs, and audio clips.
     */
    Vcard = "vcard",
    /** A video */
    Video = "video"
}
/** An auth response object */
export type Auth = {
    __typename?: 'Auth';
    /** The auth token for the user */
    token: Scalars['String']['output'];
    /** The User account */
    user: User;
};
export type BroadcastEvent = DeleteEvent | EntityEvent;
/** A group of messages between users. Can be persistent or ephemeral. Can also be branded. */
export type Chat = {
    __typename?: 'Chat';
    /** Whether the chat can be joined by outside Users */
    _private: Scalars['Boolean']['output'];
    /** The creation date of this Chat */
    created_at: Scalars['DateTime']['output'];
    /** The description of the group caht */
    description?: Maybe<Scalars['String']['output']>;
    /** Whether or not the chat is encrypted */
    encrypted: Scalars['Boolean']['output'];
    /** The ID of this Chat */
    id: Scalars['ID']['output'];
    /** THe image associated with the group chat */
    image?: Maybe<Scalars['String']['output']>;
    /** The type of chat. Available types are DirectMessage, Group, Conversation and Thread. */
    kind: ChatType;
    /** The most recent message sent to this chat if unencrypted */
    last_message?: Maybe<Message>;
    /** The members in this group Chat */
    members: Array<Member>;
    /** The name of the group chat */
    name?: Maybe<Scalars['String']['output']>;
    /** The number of unread messages for the current User in this Chat */
    unread_count: Scalars['Int']['output'];
    /** The update date of this Chat */
    updated_at: Scalars['DateTime']['output'];
};
/** A group of messages between users. Can be persistent or ephemeral. Can also be branded. */
export type ChatMembersArgs = {
    count?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
};
/** The type of a Chat entity. */
export declare enum ChatType {
    /** Represents an ephemeral Chat. A set of messages spawned around an Support Request or something of the like */
    Conversation = "Conversation",
    /** A persistent Chat between two users. */
    DirectMessage = "DirectMessage",
    /** A persistent Chat created for a group of people. Can be branded with a name, description and image, as well as members with MemberRoles */
    Group = "Group",
    /** Represents a conversation in reply to a particular message. Does not include nested threads. */
    Thread = "Thread"
}
/** The input with params necessary to create a Device */
export type CreateDeviceInput = {
    /** The type of the device */
    device_type: DeviceType;
    /** The fcm token of the device if available */
    fcm_token?: InputMaybe<Scalars['String']['input']>;
    /** The Persistent Identity Key of the Device */
    ik: Scalars['String']['input'];
    /** The Device's One Time PreKey Set */
    opk: Array<Scalars['String']['input']>;
    /** The Device's PreKey Signature Sig(IK, Encode(SPK)) */
    pks: Scalars['String']['input'];
    /** The Device's Signed PreKey */
    spk: Scalars['String']['input'];
};
/** The fields necessary to create a Flag */
export type CreateFlagInput = {
    /** The Chat ID for the Chat subject of the Flag */
    chat?: InputMaybe<Scalars['ID']['input']>;
    /** The Message ID for the Message subject of the Flag */
    message?: InputMaybe<Scalars['ID']['input']>;
    /** The reason for the flag */
    reason: Scalars['String']['input'];
    /** The User ID for the User subject of the Flag */
    user?: InputMaybe<Scalars['ID']['input']>;
};
export type CreateGroupInput = {
    /** The privacy status of the group to create */
    _private?: InputMaybe<Scalars['Boolean']['input']>;
    /** The description of the group to create */
    description?: InputMaybe<Scalars['String']['input']>;
    /** The image of the group to create */
    image?: InputMaybe<Scalars['String']['input']>;
    /** A list of User IDs to invited ot the group */
    invites?: InputMaybe<Array<InputMaybe<Scalars['ID']['input']>>>;
    /** The name of the group to create */
    name: Scalars['String']['input'];
};
export declare enum DeleteEntity {
    Chat = "Chat",
    Device = "Device",
    Message = "Message",
    User = "User"
}
export type DeleteEvent = {
    __typename?: 'DeleteEvent';
    id: Scalars['ID']['output'];
    kind: DeleteEntity;
};
/**
 * A User's logged in device containing the encryption keys
 * for E2E messages on that device and os info.
 */
export type Device = {
    __typename?: 'Device';
    /** The date this Device was created */
    created_at: Scalars['DateTime']['output'];
    /** The Device's ID as provided by the Device */
    id: Scalars['ID']['output'];
    /** The Device's Identity Key */
    ik: Scalars['String']['output'];
    /** The Device's One Time PreKey Set */
    opk: Array<Scalars['String']['output']>;
    /** The Device's PreKey Signature Sig(IK, Encode(SPK)) */
    pks: Scalars['String']['output'];
    /** The Device's Signed PreKey */
    spk: Scalars['String']['output'];
    /** The date this Device was updated */
    updated_at: Scalars['DateTime']['output'];
};
/** The type of a device, iOS, Android, or Web */
export declare enum DeviceType {
    /** An Android Device Type */
    Android = "ANDROID",
    /** An iOS Device Type */
    Ios = "IOS",
    /** A Web Device Type */
    Web = "WEB"
}
/**
 * An X3DH Double Ratchet Encrypted Message
 * Initial or Forward
 *
 * Encryption strictly follows the Signal Protocol (https://www.signal.org/docs/)
 */
export type EncryptedMessage = ForwardEncryptedMessage | InitialEncryptedMessage;
export type Entities = Chat | Member | Message | User;
export type EntityEvent = {
    __typename?: 'EntityEvent';
    entity: Entities;
    type: EntityEventType;
};
export declare enum EntityEventType {
    Create = "Create",
    Update = "Update"
}
/** NFt login input fields */
export type EthLoginInput = {
    /** The Device that is logging in */
    device?: InputMaybe<CreateDeviceInput>;
    /** The image to associate with this user */
    image?: InputMaybe<Scalars['String']['input']>;
    /** A signed message stating that the user intends to sign with the selected NFT owned by this wallet */
    signed_message: Scalars['String']['input'];
    /** The ID of the token the user is logging in with */
    token_id: Scalars['String']['input'];
    /** The username to assign to this user */
    username: Scalars['String']['input'];
    /** The wallet address */
    wallet: Scalars['String']['input'];
};
/** A Message favorited by a User */
export type Favorite = {
    __typename?: 'Favorite';
    /** The Message favorited by the User */
    message: Message;
};
/** A report of potentially illiciet content by a User */
export type Flag = {
    __typename?: 'Flag';
    /** The Chat subject of the fLag */
    chat?: Maybe<Chat>;
    /** The creation date of the flag */
    created_at: Scalars['DateTime']['output'];
    /** The user that created that Flag */
    flagged_by: User;
    /** The ID of the Flag */
    id: Scalars['ID']['output'];
    /** The Message subject of the Flag */
    message?: Maybe<Message>;
    /** The reason for the Flag */
    reason: Scalars['String']['output'];
    /** The Users that have reviewed the Flag */
    reviewers?: Maybe<Array<User>>;
    /** The reviews of reviewers */
    reviews?: Maybe<Array<Maybe<FlagReview>>>;
    /** The updated date of the flag */
    updated_at: Scalars['DateTime']['output'];
    /** The User subject of the Flag */
    user?: Maybe<User>;
};
/** A review of a Flag by a moderator */
export type FlagReview = {
    __typename?: 'FlagReview';
    /** The rationale for the review if any */
    rationale?: Maybe<Scalars['String']['output']>;
    /** The status of the review, Approved or Rejected */
    status: FlagReviewStatus;
};
/** A moderators approval status of a Flag */
export declare enum FlagReviewStatus {
    Approved = "Approved",
    Rejected = "Rejected"
}
/** A forward double ratchet encrypted message */
export type ForwardEncryptedMessage = {
    __typename?: 'ForwardEncryptedMessage';
    /** The encrypted message contents. Unencrypted it is a JSON object of the form of Message */
    content: Scalars['String']['output'];
    /** The header of the encrypted message */
    header: Scalars['String']['output'];
};
/** Input for a forward double ratchet encrypted message */
export type ForwardEncryptedMessageInput = {
    /** The encrypted message contents. Unencrypted it is a JSON object of the form {text: String, attachments: [Attachment!]!} */
    content: Scalars['String']['input'];
    /** The Signed Pre Key this encrypted message is intended for */
    spk: Scalars['String']['input'];
};
/** The initial encrypted message used to establish a Shared Key between two devices */
export type InitialEncryptedMessage = {
    __typename?: 'InitialEncryptedMessage';
    /** The encrypted message contents. Unencrypted it is a JSON object of the form {text: String, attachments: [Attachment!]!} */
    content: Scalars['String']['output'];
    /** The Ephemeral Key used to sign the message */
    ek: Scalars['String']['output'];
    /** The Sender Identity Key used to sign the message */
    ik: Scalars['String']['output'];
    /** The One Time PreKey used by this encryption, if any */
    opk?: Maybe<Scalars['String']['output']>;
    /** The PreKey this message is intended for */
    spk: Scalars['String']['output'];
};
/** Input for the initial encrypted message used to establish a Shared Key between two devices */
export type InitialEncryptedMessageInput = {
    /** The encrypted message contents. Unencrypted it is a JSON object of the form {text: String, attachments: [Attachment!]!} */
    content: Scalars['String']['input'];
    /** The Ephemeral Key used to sign the message */
    ek: Scalars['String']['input'];
    /** The Sender Identity Key used to sign the message */
    ik: Scalars['String']['input'];
    /** The One Time PreKey used by this encryption, if any */
    opk?: InputMaybe<Scalars['String']['input']>;
    /** The PreKey used by this encryption. */
    spk: Scalars['String']['input'];
};
export type InviteEvent = {
    __typename?: 'InviteEvent';
    by: User;
    to: Chat;
};
/** Login input fields */
export type LoginInput = {
    /**
     * The access token for the user on the silo owner's app network.
     * This will be used to verify the login authenticity with the silo owner's backend
     */
    access_token?: InputMaybe<Scalars['String']['input']>;
    /** The Device that is logging in */
    device?: InputMaybe<CreateDeviceInput>;
    /** The display name of the User */
    display_name?: InputMaybe<Scalars['String']['input']>;
    /** The email of the user */
    email?: InputMaybe<Scalars['String']['input']>;
    /** The image associated with the User */
    image?: InputMaybe<Scalars['String']['input']>;
    /** The ID of the user on the silo owner's app network */
    user_id: Scalars['ID']['input'];
    /** The username of the User */
    username?: InputMaybe<Scalars['String']['input']>;
};
export type MeEvent = InviteEvent | ReactionEvent | ReplyEvent;
/** A member of a Chat */
export type Member = {
    __typename?: 'Member';
    /** The Chat the Member belongs to */
    chat: Chat;
    /** The ID of the Chat the Member belongs to */
    chat_id: Scalars['String']['output'];
    /** The creation date of the membership */
    created_at: Scalars['DateTime']['output'];
    /** The date the Member last read the Chat. Maintained in order to provide unread statuses of Chats */
    last_read_at: Scalars['DateTime']['output'];
    /** THe Role of the Member in the Chat */
    role: MemberRole;
    /** The updated date of the Chat */
    updated_at: Scalars['DateTime']['output'];
    /** The User the Member represents */
    user: User;
    /** The ID of the User that is the member */
    user_id: Scalars['String']['output'];
};
/** The role of a User Member of a Chat */
export declare enum MemberRole {
    /** An Admin, has near total permissional control over a Chat */
    Admin = "Admin",
    /** An Invite sent to a User for a Chat. The User can join the Chat if invited, even if the Chat is private */
    Invited = "Invited",
    /** A User that was kicked from a group Chat. Retained in order to prevent the User rejoining the Chat. */
    Kicked = "Kicked",
    /** A member can send Messages and read Messages from a Chat */
    Member = "Member",
    /** An Owner, has total permisisonal control over a Chat */
    Owner = "Owner",
    /** A User that rejected an Invite to a Chat. Retained in order to prevent multiple Invites */
    RejectedInvite = "RejectedInvite"
}
/** An @ mention in a message text */
export type Mention = {
    __typename?: 'Mention';
    /** The position of the offset in the text */
    offset: Scalars['Int']['output'];
    /** The ID of the user mentioned */
    user_id: Scalars['ID']['output'];
    /** The username of the user mentioned */
    username: Scalars['String']['output'];
};
/** A Message sent by a User to Chat */
export type Message = {
    __typename?: 'Message';
    /** Attachments to the Message */
    attachments?: Maybe<Array<Attachment>>;
    /** The Chat this Message belongs to */
    chat: Chat;
    /** The ID of the Chat this message belongs to */
    chat_id: Scalars['String']['output'];
    /** The creation date of the Message */
    created_at: Scalars['DateTime']['output'];
    /** The ID of the Message */
    id: Scalars['ID']['output'];
    /** The mentions in the message */
    mentions?: Maybe<Array<Mention>>;
    /** The Message this Message is in reply to if it is a reply */
    parent?: Maybe<Message>;
    /** The ID of the Message this Message is in reply to if it is a reply */
    parent_id?: Maybe<Scalars['String']['output']>;
    /** Reactions to the Message, string of the form reaction1:uid1,uid2...;reaction2:uid1,uid2... */
    reactions?: Maybe<Scalars['String']['output']>;
    /** The number of replies to this Message */
    reply_count: Scalars['Int']['output'];
    /**
     * System Messages are special messages that are not sent by Users
     * if this is null it is not a system message
     * if is filled, this is a system message of the specified type
     */
    system?: Maybe<SystemMessageType>;
    /** The text content of the Message. Can contain Markdown */
    text?: Maybe<Scalars['String']['output']>;
    /** The updated date of the Message */
    updated_at: Scalars['DateTime']['output'];
    /** The User that sent this Message */
    user: User;
};
export type Mutation = {
    __typename?: 'Mutation';
    /** Blocks a User for the current User */
    block?: Maybe<Scalars['Boolean']['output']>;
    /** Create a new group Chat */
    createGroup?: Maybe<Chat>;
    /** Delete a group Chat */
    deleteGroup?: Maybe<Scalars['Boolean']['output']>;
    /** Start a directmessage Chat with a User */
    dm?: Maybe<Chat>;
    /** Login as an NFT authenticated user */
    ethLogin?: Maybe<Auth>;
    /** Favorite a Message as the current User */
    favorite?: Maybe<Scalars['Boolean']['output']>;
    /** Flag a User, Chat or Message */
    flag: Flag;
    /** Invites a User to a Chat */
    invite: Member;
    /**
     * Joins a Chat. Always succeeds if that Chat is public and the user hasn't been Kicked.
     * If the Chat is private, success only occurs if the User has been invited.
     */
    join?: Maybe<Member>;
    /** Leaves a Chat */
    leave?: Maybe<Scalars['Boolean']['output']>;
    /** Login as User from the Chat silo owner's App */
    login?: Maybe<Auth>;
    /** Logs out of a device, deleting it, and wiping out the auth token */
    logout?: Maybe<Scalars['Boolean']['output']>;
    /** Marks a Chat as read now for the current User */
    markChatRead?: Maybe<Scalars['Boolean']['output']>;
    /** React to a Message as the current User. If no reaction is passed, the reaction for the current User is removed. */
    react?: Maybe<Scalars['Boolean']['output']>;
    /** Consume all Messages for the current Device up to a given Message header */
    read?: Maybe<Scalars['Boolean']['output']>;
    /** Registers a push token for a device */
    registerPush?: Maybe<Scalars['Boolean']['output']>;
    /** Rejects a Chat invite for the current User */
    rejectInvite?: Maybe<Scalars['Boolean']['output']>;
    /** Delete a Flag */
    removeFlag?: Maybe<Flag>;
    /** Delete a Message if priveledged */
    removeMessage?: Maybe<Scalars['Boolean']['output']>;
    /** A content review for a Flag */
    reviewFlag: Flag;
    /** Send an Encrypted Message */
    sendEncryptedMessage?: Maybe<Scalars['Boolean']['output']>;
    /** Send a message to a Chat */
    sendMessage: Message;
    /** Unblocks a User for the current User */
    unblock?: Maybe<Scalars['Boolean']['output']>;
    /** Unfavorite a Message as the current User */
    unfavorite?: Maybe<Scalars['Boolean']['output']>;
    /** Update a Device */
    updateDevice: Device;
    /** Update a group Chat */
    updateGroup: Scalars['Boolean']['output'];
    /** Update the contents of a Message */
    updateMessage: Message;
    /** Updates the current User's profile */
    updateProfile: User;
};
export type MutationBlockArgs = {
    user: Scalars['ID']['input'];
};
export type MutationCreateGroupArgs = {
    input: CreateGroupInput;
};
export type MutationDeleteGroupArgs = {
    id?: InputMaybe<Scalars['String']['input']>;
};
export type MutationDmArgs = {
    user: Scalars['ID']['input'];
};
export type MutationEthLoginArgs = {
    input: EthLoginInput;
};
export type MutationFavoriteArgs = {
    id: Scalars['ID']['input'];
};
export type MutationFlagArgs = {
    input: CreateFlagInput;
};
export type MutationInviteArgs = {
    chat?: InputMaybe<Scalars['ID']['input']>;
    user?: InputMaybe<Scalars['ID']['input']>;
};
export type MutationJoinArgs = {
    chat: Scalars['ID']['input'];
};
export type MutationLeaveArgs = {
    chat: Scalars['ID']['input'];
};
export type MutationLoginArgs = {
    input: LoginInput;
};
export type MutationMarkChatReadArgs = {
    chat: Scalars['ID']['input'];
};
export type MutationReactArgs = {
    id: Scalars['ID']['input'];
    reaction?: InputMaybe<Scalars['String']['input']>;
};
export type MutationReadArgs = {
    header: Scalars['String']['input'];
};
export type MutationRegisterPushArgs = {
    fcm?: InputMaybe<Scalars['Boolean']['input']>;
    kind: DeviceType;
    token: Scalars['String']['input'];
};
export type MutationRejectInviteArgs = {
    chat?: InputMaybe<Scalars['ID']['input']>;
};
export type MutationRemoveFlagArgs = {
    id: Scalars['String']['input'];
};
export type MutationRemoveMessageArgs = {
    id: Scalars['String']['input'];
};
export type MutationReviewFlagArgs = {
    input: ReviewFlagInput;
};
export type MutationSendEncryptedMessageArgs = {
    input: SendEncryptedMessageInput;
};
export type MutationSendMessageArgs = {
    input?: InputMaybe<SendMessageInput>;
};
export type MutationUnblockArgs = {
    user: Scalars['ID']['input'];
};
export type MutationUnfavoriteArgs = {
    id: Scalars['ID']['input'];
};
export type MutationUpdateDeviceArgs = {
    input: UpdateDeviceInput;
};
export type MutationUpdateGroupArgs = {
    input: UpdateGroupInput;
};
export type MutationUpdateMessageArgs = {
    input: UpdateMessageInput;
};
export type MutationUpdateProfileArgs = {
    input: UpdateProfileInput;
};
/** A User's online status in this Chat silo */
export declare enum OnlineStatus {
    /** A user that is connected to the network but is "Away". This suggests a likely response in the near future */
    Away = "Away",
    /**
     * A user that has explicitely marked their Chat availbility as Do Not Disturb.
     * The user is actively connected to the network and would like his peers to know he is connect4ed, but does not wish to receive any messages.
     */
    Dnd = "DND",
    /** The user is not connected to the network. This suggests an entirely random response time */
    Offline = "Offline",
    /** Actively available. The suggests a near immediate response */
    Online = "Online"
}
export type Query = {
    __typename?: 'Query';
    /** Returns the current User's active list of groups */
    activeGroups: Array<Chat>;
    app: App;
    /** Returns a chat with the specified ID */
    chat?: Maybe<Chat>;
    /** Returns the list of devices for a Chat */
    devices: Array<Device>;
    /** Returns the currents User's active list of dms */
    dms: Array<Chat>;
    /** Returns the Messages favorited by the current User in descending order */
    favorites: Array<Message>;
    /** The list of Flags available, unreviewed or neither */
    flags: Array<Flag>;
    /** Lists public and private Group chats on the network */
    groups: Array<Chat>;
    /** The Device's inbox of Messages */
    inbox: Array<EncryptedMessage>;
    /** The current User */
    me?: Maybe<User>;
    /** The members of a Chat */
    members: Array<Member>;
    /** Retrieves a User's memberships */
    memberships: Array<Member>;
    /** Fetch a Message by ID */
    message?: Maybe<Message>;
    /** The messages in a Chat. Can be filted by a search term */
    messages: Array<Message>;
    /** The replies to a Message */
    replies: Array<Message>;
    /** Retrieves a User by ID */
    user?: Maybe<User>;
    /** Retrieves Users in the current Chat silo */
    users: Array<User>;
};
export type QueryActiveGroupsArgs = {
    count?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
};
export type QueryChatArgs = {
    id: Scalars['ID']['input'];
};
export type QueryDevicesArgs = {
    chat: Scalars['ID']['input'];
};
export type QueryDmsArgs = {
    count?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
};
export type QueryFavoritesArgs = {
    count?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
};
export type QueryFlagsArgs = {
    count?: InputMaybe<Scalars['Int']['input']>;
    notReviewed?: InputMaybe<Scalars['Boolean']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
};
export type QueryGroupsArgs = {
    count?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
};
export type QueryMembersArgs = {
    chat: Scalars['ID']['input'];
    count?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
};
export type QueryMembershipsArgs = {
    user?: InputMaybe<Scalars['ID']['input']>;
};
export type QueryMessageArgs = {
    id: Scalars['String']['input'];
};
export type QueryMessagesArgs = {
    chat: Scalars['ID']['input'];
    count?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    searchTerm?: InputMaybe<Scalars['String']['input']>;
};
export type QueryRepliesArgs = {
    count?: InputMaybe<Scalars['Int']['input']>;
    message: Scalars['ID']['input'];
    offset?: InputMaybe<Scalars['Int']['input']>;
};
export type QueryUserArgs = {
    id: Scalars['ID']['input'];
};
export type QueryUsersArgs = {
    botsOnly?: InputMaybe<Scalars['Boolean']['input']>;
    count?: InputMaybe<Scalars['Int']['input']>;
    offset?: InputMaybe<Scalars['Int']['input']>;
    searchTerm?: InputMaybe<Scalars['String']['input']>;
};
export type ReactionEvent = {
    __typename?: 'ReactionEvent';
    message: Message;
    reaction: Scalars['String']['output'];
    user: User;
};
export type ReplyEvent = {
    __typename?: 'ReplyEvent';
    message: Message;
};
/** The review content input for  a Flag review */
export type ReviewFlagInput = {
    /** The ID of the Flag to review */
    flag: Scalars['ID']['input'];
    /** The rationale for the review status if any */
    rationale?: InputMaybe<Scalars['String']['input']>;
    /** The rational status, Approved or Rejected */
    status: FlagReviewStatus;
};
/** Input for sending an Encrypted Message */
export type SendEncryptedMessageInput = {
    device: Scalars['ID']['input'];
    forward?: InputMaybe<ForwardEncryptedMessageInput>;
    initial?: InputMaybe<InitialEncryptedMessageInput>;
};
/** The input necessary to send a Message to a Chat */
export type SendMessageInput = {
    /** Input Attachments to include with the Message */
    attachments?: InputMaybe<Array<AttachmentInput>>;
    /** The Chat to send the Message to */
    chat: Scalars['ID']['input'];
    /** The ID of the Message this Message is replying to if it is a reply */
    parent?: InputMaybe<Scalars['ID']['input']>;
    /** The text content of the message. May contain markdown and @mentions */
    text?: InputMaybe<Scalars['String']['input']>;
};
export type Subscription = {
    __typename?: 'Subscription';
    core: BroadcastEvent;
    me: MeEvent;
};
/** A kind of System Message */
export declare enum SystemMessageType {
    Default = "Default",
    UserJoined = "UserJoined",
    UserLeft = "UserLeft"
}
/** A User's Role in this Chat silo */
export declare enum TenantUserRole {
    /** A User with Admin priveleges */
    Admin = "Admin",
    /** A standard User, can Chat, create Groups and update own Profile */
    Member = "Member",
    /** A moderator, can manage flags, and content */
    Moderator = "Moderator",
    /** A fully priveleged User */
    Owner = "Owner"
}
/** The params to update a device */
export type UpdateDeviceInput = {
    /** The Device's One Time PreKey Set */
    opk: Array<Scalars['String']['input']>;
    /** The Device's PreKey Signature Sig(IK, Encode(SPK)) */
    pks: Scalars['String']['input'];
    /** The Device's Signed PreKey */
    spk: Scalars['String']['input'];
};
/** Represents the fields updatable on a group Chat */
export type UpdateGroupInput = {
    /** The new privacy of the group */
    _private?: InputMaybe<Scalars['Boolean']['input']>;
    /** The new description of the group */
    description?: InputMaybe<Scalars['String']['input']>;
    /** The ID of the chat to update */
    id: Scalars['ID']['input'];
    /** The new image of the group */
    image?: InputMaybe<Scalars['String']['input']>;
    /** The new name of the group */
    name?: InputMaybe<Scalars['String']['input']>;
};
/** The input to update a Message */
export type UpdateMessageInput = {
    /** Input Attachments to include with the Message. Replaces the old attachments array */
    attachments?: InputMaybe<Array<InputMaybe<AttachmentInput>>>;
    /** The ID of the Message to update */
    id: Scalars['ID']['input'];
    /** The ID of the Message this Message is replying to if it is a reply */
    parent?: InputMaybe<Scalars['ID']['input']>;
    /** The text content of the message. May contain markdown and @mentions */
    text?: InputMaybe<Scalars['String']['input']>;
};
/** The available fields for updating on the current User's profile */
export type UpdateProfileInput = {
    /** The User's desired new display name */
    display_name?: InputMaybe<Scalars['String']['input']>;
    /** The User's desired new image */
    image?: InputMaybe<Scalars['String']['input']>;
    /** The User's desired new online status */
    status?: InputMaybe<OnlineStatus>;
    /** The User's desired new username */
    username?: InputMaybe<Scalars['String']['input']>;
};
/** A chat User. This user only exists in this Chat silo */
export type User = {
    __typename?: 'User';
    /** The IDs fo Users that have blocked this User */
    blocked_by?: Maybe<Array<Scalars['ID']['output']>>;
    /** The IDs of Users this User has blocked */
    blocks?: Maybe<Array<Scalars['ID']['output']>>;
    /** The date this User was created */
    created_at: Scalars['DateTime']['output'];
    /** The User's bio or profile description */
    description?: Maybe<Scalars['String']['output']>;
    /** The User's devices */
    devices: Array<Device>;
    /** A freeform display name for a user. Can contain emojis */
    display_name?: Maybe<Scalars['String']['output']>;
    /** The ID of the User */
    id: Scalars['ID']['output'];
    /** The image associated with the User */
    image?: Maybe<Scalars['String']['output']>;
    /** Whether or not this user is an AI bot or */
    is_bot?: Maybe<Scalars['Boolean']['output']>;
    /** Last seen date of the user */
    last_seen: Scalars['DateTime']['output'];
    /** The Role of this User in their Chat silo */
    role: TenantUserRole;
    /** The online status of this user */
    status: OnlineStatus;
    /** The date this User was updated */
    updated_at: Scalars['DateTime']['output'];
    /** This User's unique handle. Can be alphanumeric and "_" */
    username: Scalars['String']['output'];
};
